#Алгоритм работы сервера

1. WSS серверу присвоить объект rooms.

   1. Ключами объекта являются комнаты
   2. Значениями являются массивы
   3. массивы заполняются клиентами, которые зашли в конкретную комнату

#Алгоритм работы front-end

1. **Класс Client**

   1. Инициация связи с сигнальным сервером
   2. Обработка событий сигнального сервера:
      1. _Событие входа_
         1. Отправить на сервер JSON с именем, названием комнаты.
         2. После ответа сервера, запросить userMedia
         3. Пройтись по массиву участников и вызвать функцию createOffer передав имя участниа (Состав оффера в пункте 1.3.1)
      2. _Событие выхода_
      3. _Событие нового участника_
         1. Принять имя нового участника.
   3. WebRTC
      1. Состав Оффера
         1. Пройтись по вернувшемуся массиву пользователей(п.1.2.2) (создав объект PC с ключами = имя, а значение RTCPeerConnection), и для каждого создать RTCPeerConnection. В конструктором ICE конфигурацию
         2. Для каждого ключа добавить обработчик _onicecandidate_, _onaddstream_, _onremovestream_
         3. Также добавить локальный стрим через _addStream_
         4. Добавить в объект sendChannel для каждого ключа добавить DataChannel каждого РС с первым аргументом "sendDataChannel" (это просто название канала) в конструкторе
            `sendChannel[name] = _PC[name].createDataChannel("sendDataChannel");`
         5. sendChannel[name] присвоить обработчики для _onmessage_, _onopen_, _onclose_
         6. прислать текущему PC[name] оффер
         7. При успешном оффере, добавить PC[name] локальный дескриптор
      2. Получение оффера 1. создать setRemoteDescription(new RTCSessionDescription(offer)) для PC[fromName] 2. Создать ответ

2. **Сообщения от клиента**
   1. _Событие входа_.
      1. Проверить свободно ли такое имя в выбранной комнате
      2. Присвоить св-во name сокету клиента
      3. Добавить в нужную комнату _(массив WSS.rooms[data.room])_ нового клиента
      4. Отправить обратно клиенту массив имен пользователей текущей комнаты
      5. Отправить ВСЕМ пользователям комнаты КРОМЕ текущего клиента информацию о новом клиенте
   2. _Событие выхода_
      1. Отправить на сервер сообщение о выходе вместе с информацией о комнате
      2. На ответ сервера, все другие пользователи удаляют указанного пользователя в ответе
      3. Очистить внешний вид страницы для вышедшего пользователя
   3. _Событие нового пользователя_
      1. Добавить новую разметку в список участников чата

##Login form (app.js)

1. Создать новую сущность клиента передав в конструктор websocket
2. Обработка событий DOM
   1. _Событие входа_
      1. Проверить наличие ввода имени
      2. Присвоить имя сущности клиента
      3. Вызвать метод подключения к выбраной комнате
      4. Принять WS со списком пользователей комнаты (или новым пользователем) и добавить существующих пользователей
   2. _Событие смены комнаты_
   3. _Событие выхода_

##Class Client.js

1. Должен инициировать связь с сигнальным сервером.
2. Обрабатывать сообщения сигнального сервера.
   1. _Событие входа_
   2. _Событие смены комнаты_
   3. _Новый участник_
      1. Сохранить имя нового участника
      2. ыфв

#Алгоритм работы WebRTC

1. При входе в комнату у класса Клиент делать запрос getUserMedia.

Добавить window.onbeforeunload сообщение к серверу о покидании.

1. При составлении оффера для каждого в пира в объект с ключом (имя участника) добавить значением RTCPeerConnection(configuration)
2. Повесить обработчики событий на _onicecandidate_, _onaddstream_, _onremovestream_
3. Добавить этому ключу локальный стримaddStream(localStream)
4. открыть датастрим
5. При успешном оффере добавить этому ключу setLocalDescription(data) с из коллбэка
   `PC[SOMENAME].createOffer(function(offer) { send({ type: "offer", offer: offer }); yourConn.setLocalDescription(offer); }, function(error) { alert("Error when creating an offer"); });`
6. Также реализовать обработку оффера
   1. При получении офера добавляем ключу объекта с пирами (отдельный объект для офферов или для ответов) setRemoteDescription(new RTCSessionDescription(offer))
   2. Отправляем ответ и в успешном коллбеке устанавливаем setLocalDescription
      `PC[SOMENAME].createAnswer(function(answer) { yourConn.setLocalDescription(answer); send({ type: "answer", answer: answer }); }, function(error) { alert("Error when creating an answer"); });`
7. При получении ответа добавляем нужному ключу setRemoteDescription(new RTCSessionDescription(answer))
8. При получении кандидата добавляем нужному ключу addIceCandidate(new RTCIceCandidate(candidate))
